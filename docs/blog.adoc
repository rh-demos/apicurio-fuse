= How to do API first design with OpenAPI and Fuse

API first is a commonly used practice, where you define the interfaces for your application, before providing an actual implementation. This approach gives you a lot of benefits. You can try out if your API has the right structure, before investing a lot of time in implementing it, and you can share your ideas with other teams early to get valuable feedback. Later in the process delays in the backend development will not affect front end developers dependent on your service so much, because it's easy to create mock implementations of a service from the API definition. A lot has been written about the benefits of API first design, so this article will instead focus on, how to  efficiently take an https://swagger.io/specification/[OpenAPI] definition and bring it into code with Fuse.

Imagine an API has been designed for you. The API is used for exposing a beer API https://github.com/microcks/api-lifecycle/blob/master/beer-catalog-demo/api-contracts/beer-catalog-api-swagger.json . Its pretty simple and consists of three operations:

* GetBeer - Get a beer by name
* FindBeersByStatus - Find a beer by its status
* ListBeers - Get all beers in the database

As you can see in the json file, each operation is identified by an _operationId_. That will show to be handy, when doing the actual implementation.

== Keeping generated code separate from the implementation
We don’t want to code all the DTOs and boiler plate code, since that’s very time consuming and trivial as well. Therefore we use the https://github.com/apache/camel/blob/master/tooling/maven/camel-restdsl-swagger-plugin/src/main/docs/camel-restdsl-swagger-plugin.adoc[Camel REST DSL Swagger Maven Plugin] for generating all of that.

We want to keep the code generated by the swagger plugin separate from our implementation. There are several reasons for this:
* Code generation consumes time and resources. Separating code generation from compiling allow us to use less time waiting and thus more time for drinking coffee with the colleagues and be creative in all sorts of ways:-)
* We don't have to worry that a developer accidentally puts some implementation stuff in an autogenerated class and as a consequence loose valuable work next time the stub is regenerated. Of course we've got everything under version control, but it's still time consuming to resolve what was done, moving code, etc.
* Other projects can refer to the generated artifacts independently of the implementation.

To keep the generated stub separate from the implementation, we have the following initial structure:
----
.
├── README.md
├── fuse-impl
│   ├── pom.xml
│   └── src
│       ├── main
│       │   ├── java
│       │   └── resources
│       └── test
│           ├── java
│           └── resources
└── stub
    ├── pom.xml
    └── src
        └── spec
----

The folder _stub_ contains the project for the generated artifacts. The folder _fuse-impl_ contains our implementation of the actual service.

== Setting up code generation with swagger
First configure the swagger plugin by adding the following in the pom.xml file for the stub project:

----
…
<dependencies>
  <dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-swagger-java-starter</artifactId>
  </dependency>
…
</dependencies>
…
<plugins>
  <plugin>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-restdsl-swagger-plugin</artifactId>
    <version>2.23.0</version>
    <executions>
      <execution>
        <goals>
          <goal>generate-xml-with-dto</goal><!-- 1 -->
        </goals>
      </execution>
    </executions>
    <configuration>
      <specificationUri><!-- 2 -->
        ${project.basedir}/src/spec/beer-catalog-API.json
      </specificationUri>
      <fileName>camel-rest.xml</fileName><!-- 3 -->
      <outputDirectory><!-- 4 -->
              ${project.build.directory}/generated-sources/src/main/resources/camel-rest
      </outputDirectory>
      <modelOutput>
        ${project.build.directory}/generated-sources
      </modelOutput>
      <modelPackage>com.example.beer.dto</modelPackage><!-- 5 -->
    </configuration>
  </plugin>
</plugins>
...
----

The plugin is pretty easy to configure:
. The goal is set to _generate-xml-with-dto_, which means that a rest DSL xml file is generated from the definition together with my Data Transfer Objects. There are other options including one to generate a Java client for the interface.
. _specificationUri_ points to the location of my API definition.
. The name of the rest DSL xml file to generate.
. Where to output the generated rest DSL xml file. If placed it in this location, Camel will automatically pick it up if included in a project.
. Package name for the DTOs

In _pom.xml_ we also need to change the location of the source and resource files for the compiler. Finally we need to copy the API specification to the location we chose previously. This isn't described in this blog as it's known stuff, but if in doubt refer to the https://github.com/rh-demos/apicurio-fuse[source code] for the specifics. Then we're ready to generate the stub for the rest service.

So far we have the following file structure in the _stub_ project:

----
.
└── stub
    ├── pom.xml
    └── src
        └── spec
            └── beer-catalog-API.json
----

Run _mvn install_ in the _stub_ dir and the stub is automatically generated and put into the local repository. The DTOs are generated in the package we chose previously. Furthermore an xml file is created for the rest endpoint.

.stub/target/generated-sources/src/main/resources/camel-rest/camel-rest.xml
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<rests xmlns="http://camel.apache.org/schema/spring">
    <restConfiguration component="servlet"/>
    <rest>
        <get id="GetBeer" uri="/beer/{name}">
            <description>Get beer having name</description>
            <param dataType="string" description="Name of beer to retrieve" name="name" required="true" type="path"/>
            <to uri="direct:GetBeer"/>
        </get>
        <get id="FindBeersByStatus" uri="/beer/findByStatus/{status}">
            <description>Get beers having status</description>
            <param dataType="string" description="Status of beers to retrieve" name="status" required="true" type="path"/>
            <param dataType="number" description="Number of page to retrieve" name="page" required="false" type="query"/>
            <to uri="direct:FindBeersByStatus"/>
        </get>
        <get id="ListBeers" uri="/beer">
            <description>List beers within catalog</description>
            <param dataType="number" description="Number of page to retrieve" name="page" required="false" type="query"/>
            <to uri="direct:ListBeers"/>
        </get>
    </rest>
</rests>
----

The important thing to note is that each rest operation is routing to a _uri_ named _direct:operatorId_, which is the same operator as in the API definition file. This enables us to easily provide an implementation for each operation.

== Providing an implementation of the API
For the example implementation we choose Fuse running in a Spring boot container to make it easily deployable in OpenShift.

Besides the usual boilerplate code, only thing we have to do is to add a dependency to the project containing the stub in our pom.xml:
----
    <dependency>
      <groupId>com.example</groupId>
      <artifactId>beer</artifactId>
      <version>1.0</version>
    </dependency>
----

Now we're all set and all we have to do is to provide is our implementation of the three operations. As an example of an implementation, consider the following example.

.src/main/java/com/example/beer/routes/GetBeerByNameRoute.java
----
package com.example.beer.routes;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.model.dataformat.JsonLibrary;
import org.springframework.stereotype.Component;

import com.example.beer.service.BeerService;
import com.example.beer.dto.Beer;
import org.apache.camel.BeanInject;

@Component
public class GetBeerByNameRoute extends RouteBuilder {
	@BeanInject
	private BeerService mBeerService;
	
    @Override
    public void configure() throws Exception {
        from("direct:GetBeer")
                .process( new Processor(){

                    @Override
                    public void process(Exchange exchange) throws Exception {
                        String name = exchange.getIn().getHeader("name", String.class);
                        if(name == null) {
                            throw new IllegalArgumentException("must provide a name");
                        }
                        Beer b = mBeerService.getBeerByName(name);

                        exchange.getIn().setBody(b == null? new Beer(): b);
                    }
                })
                .marshal().json(JsonLibrary.Jackson);
    }
}
----
We inject a _BeerService_ which holds the information about the different beers. Then we define a direct endpoint, which provides the endpoint, which the rest call is routed to (remember the _operationId_ mentioned earlier?). The processor tries to lookup the beer. If no beer is found, an empty beer object is returned. To try out the example run:
----
mvn package
java -jar fuse-impl/target/beer-svc-impl-1.0-SNAPSHOT.jar
#in a separate terminal
curl http://localhost:8080/rest/beer/Carlsberg
{"name":"Carlsberg","country":"Denmark","type":"pilsner","rating":5,"status":"available"}
----

We might have to do this over and over again. In that case, we can create a maven archetype for the two projects. Alternatively we can clone a template project, containing all the boilerplate code and do the necessary changes from there. That will be a bit more work though, as we'll have to rename maven modules as well as java classes, but it's not too much of a hassle.

You can use the https://github.com/rh-demos/apicurio-fuse[example code] as a starting point.

